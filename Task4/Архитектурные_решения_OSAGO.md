# Архитектурные решения для продажи ОСАГО

## Обзор решения

Для реализации продажи ОСАГО онлайн создан отдельный сервис **osago-aggregator**, который отвечает за взаимодействие со страховыми компаниями и агрегацию предложений. Сервис спроектирован с учетом требований высокой нагрузки (2500 одновременных пользователей) и необходимости отображения предложений в реальном времени.

## 1. Архитектура osago-aggregator

### 1.1. Хранилище данных

**Решение: Требуется собственное хранилище данных**

**Обоснование:**
1. **Хранение состояния заявок** - необходимо отслеживать статус каждой заявки (создана, в обработке, получены предложения, завершена)
2. **Хранение предложений** - предложения от страховых компаний приходят асинхронно, их нужно сохранять до передачи в core-app
3. **Отслеживание опроса** - контроль, от каких компаний уже получены ответы, какие еще ожидаются
4. **Идемпотентность** - предотвращение дублирования заявок при повторных запросах
5. **Аудит и аналитика** - история взаимодействий со страховыми компаниями для анализа производительности

**Технология:** PostgreSQL (консистентность с остальной архитектурой)

**Схема данных:**
- `osago_requests` - заявки на ОСАГО
- `osago_offers` - предложения от страховых компаний
- `insurance_company_status` - статус взаимодействия с каждой компанией по заявке

### 1.2. Функциональность osago-aggregator

**Основные обязанности:**
1. Прием заявок от core-app
2. Параллельная отправка заявок во все доступные страховые компании
3. Асинхронный опрос решений по заявкам (polling)
4. Сохранение предложений в БД
5. Push-уведомления в core-app о новых предложениях
6. Управление таймаутами (60 секунд)

**Особенности реализации:**
- Параллельная обработка запросов к страховым компаниям
- Асинхронный опрос решений (не блокирует основной поток)
- Изоляция ошибок - сбой одной компании не влияет на другие
- Частичный успех - возврат предложений от доступных компаний

## 2. API osago-aggregator для core-app

### 2.1. REST API

**POST /api/v1/osago/requests**
- Создание новой заявки на ОСАГО
- Принимает данные об автомобиле и клиенте
- Возвращает `requestId` для отслеживания статуса
- Инициирует параллельную отправку заявок во все страховые компании

**GET /api/v1/osago/requests/{requestId}**
- Получение текущего статуса заявки
- Возвращает список полученных предложений
- Возвращает информацию о статусе опроса каждой страховой компании

**GET /api/v1/osago/requests/{requestId}/offers**
- Получение всех предложений по заявке
- Возвращает полную информацию о предложениях

### 2.2. WebSocket API для push-уведомлений

**WebSocket: /ws/osago/requests/{requestId}**
- Подключение core-app к WebSocket для получения уведомлений о новых предложениях
- При получении предложения от страховой компании отправляется событие в реальном времени
- Формат события: `{ "type": "offer_received", "requestId": "...", "offer": {...} }`

**Преимущества WebSocket:**
- Мгновенная доставка предложений без необходимости polling
- Снижение нагрузки на сервер (нет периодических запросов)
- Эффективное использование ресурсов

## 3. Средство интеграции между core-app и osago-aggregator

**Решение: REST API + WebSocket**

**Обоснование:**
1. **REST API** - для синхронных операций (создание заявки, получение статуса)
   - Простота реализации
   - Стандартный подход для HTTP-взаимодействий
   - Легкая отладка и мониторинг

2. **WebSocket** - для асинхронных push-уведомлений о новых предложениях
   - Требование бизнеса: отображение предложений сразу при получении
   - Избежание polling и снижение нагрузки
   - Эффективная доставка событий в реальном времени

**Альтернативы, которые были рассмотрены:**
- **Server-Sent Events (SSE)** - проще, но односторонняя связь, менее гибко
- **Kafka** - избыточно для point-to-point коммуникации, добавляет задержку
- **Polling** - не соответствует требованию "сразу, как только пришёл ответ"

## 4. API для веб-приложения в core-app

### 4.1. REST API

**POST /api/v1/osago/application**
- Создание заявки на ОСАГО от пользователя
- Принимает данные об автомобиле
- Возвращает `applicationId` и `requestId`

**GET /api/v1/osago/application/{applicationId}**
- Получение статуса заявки пользователя
- Возвращает текущие предложения

### 4.2. WebSocket для веб-приложения

**WebSocket: /ws/osago/application/{applicationId}**
- Подключение веб-приложения к WebSocket
- Получение уведомлений о новых предложениях в реальном времени
- Отображение предложений на экране пользователя сразу при получении

**Преимущества:**
- Соответствие требованию бизнеса: "предложения отображались сразу, как только от неё пришёл ответ"
- Улучшенный UX - пользователь видит предложения по мере их поступления
- Снижение нагрузки на сервер (нет необходимости в polling)

## 5. Средство интеграции между веб-приложением и core-app

**Решение: REST API + WebSocket**

**Обоснование:**
1. **REST API** - для стандартных HTTP-операций (создание заявки, получение данных)
   - Совместимость с существующей инфраструктурой
   - Простота реализации на фронтенде
   - Стандартный подход

2. **WebSocket** - для получения предложений в реальном времени
   - Критическое требование: отображение предложений сразу при получении
   - Улучшенный пользовательский опыт
   - Эффективное использование ресурсов

## 6. Паттерны отказоустойчивости

### 6.1. Rate Limiting

**Применение:**
- **На уровне API Gateway** для веб-приложения → core-app
- **В osago-aggregator** для защиты от перегрузки при создании заявок
- **На уровне core-app** для защиты от перегрузки при запросах от веб-приложения

**Конфигурация:**
- 100 запросов в минуту на пользователя (веб-приложение)
- 1000 запросов в минуту на сервис (core-app → osago-aggregator)

**Обоснование:**
- Защита от DDoS и перегрузки системы
- Обеспечение справедливого распределения ресурсов
- Предотвращение каскадных сбоев при пиковых нагрузках

### 6.2. Circuit Breaker

**Применение:**
- **osago-aggregator → страховые компании** (критически важно)
- **core-app → osago-aggregator** (опционально, для дополнительной защиты)

**Конфигурация:**
- **Failure threshold:** 50% ошибок за последние 10 запросов
- **Timeout:** 5 секунд на запрос к страховой компании
- **Half-open timeout:** 30 секунд (попытка восстановления)
- **Open timeout:** 60 секунд (полное отключение)

**Обоснование:**
- Изоляция ошибок - сбой одной страховой компании не блокирует работу с другими
- Быстрое обнаружение проблемных интеграций
- Автоматическое восстановление при нормализации работы
- Предотвращение каскадных сбоев

**Реализация:**
- Использование Resilience4j (для Kotlin/Spring Boot)
- Мониторинг состояния Circuit Breaker через метрики

### 6.3. Retry

**Применение:**
- **osago-aggregator → страховые компании** (при создании заявки и опросе решений)
- **core-app → osago-aggregator** (при временных сбоях)

**Конфигурация:**
- **Max attempts:** 3 попытки
- **Backoff strategy:** Exponential backoff (1s, 2s, 4s)
- **Retryable errors:** 5xx ошибки, таймауты, сетевые ошибки
- **Non-retryable errors:** 4xx ошибки (кроме 429 - Too Many Requests)

**Обоснование:**
- Обработка временных сбоев (сеть, перегрузка сервера)
- Увеличение надежности системы
- Автоматическое восстановление при кратковременных проблемах

**Особенности:**
- Retry применяется только к операциям создания заявки
- Для опроса решений используется отдельная логика с таймаутом

### 6.4. Timeout

**Применение:**
- **osago-aggregator → страховые компании** (при создании заявки и опросе решений)
- **core-app → osago-aggregator** (при создании заявки)
- **Веб-приложение → core-app** (при создании заявки)

**Конфигурация:**
- **Создание заявки в страховой компании:** 10 секунд
- **Опрос решения по заявке:** 5 секунд на запрос
- **Общий таймаут получения предложений:** 60 секунд (требование бизнеса)
- **WebSocket соединение:** keep-alive ping каждые 30 секунд

**Обоснование:**
- Соответствие требованию: "максимальное время ожидания решения от страховой компании — 60 секунд"
- Предотвращение зависания запросов
- Быстрое обнаружение проблемных интеграций
- Обеспечение отзывчивости системы

**Реализация:**
- Timeout на уровне HTTP клиента (OkHttp, Apache HttpClient)
- Таймер на уровне приложения для общего контроля 60 секунд
- Автоматическое завершение опроса по истечении таймаута

## 7. Учет множественных экземпляров сервисов

### 7.1. Проблемы множественных экземпляров

**Проблема 1: Дублирование опроса решений**
- Несколько экземпляров osago-aggregator могут одновременно опрашивать одну и ту же заявку
- Приводит к избыточным запросам к страховым компаниям
- Увеличивает нагрузку и может вызвать rate limiting

**Проблема 2: WebSocket соединения**
- Каждый экземпляр core-app имеет свое WebSocket соединение с osago-aggregator
- Необходимо маршрутизировать уведомления к правильному экземпляру core-app
- При падении экземпляра нужно переподключение

**Проблема 3: Состояние заявок**
- Несколько экземпляров osago-aggregator работают с одной БД
- Необходима координация для предотвращения race conditions

### 7.2. Решения

**Решение 1: Распределенная блокировка для опроса**

**Механизм:**
- Использование Redis для распределенных блокировок
- Перед опросом решения экземпляр osago-aggregator пытается получить блокировку по `requestId + companyId`
- Только один экземпляр опрашивает конкретную заявку у конкретной компании
- Блокировка освобождается после получения ответа или таймаута

**Преимущества:**
- Предотвращение дублирования запросов
- Эффективное использование ресурсов
- Масштабируемость - можно добавлять экземпляры без проблем

**Решение 2: WebSocket через Message Broker**

**Механизм:**
- Использование Redis Pub/Sub или RabbitMQ для маршрутизации уведомлений
- osago-aggregator публикует событие о новом предложении в топик
- Каждый экземпляр core-app подписывается на топик и проверяет, относится ли событие к его заявкам
- Альтернатива: использование sticky sessions в load balancer для маршрутизации WebSocket к тому же экземпляру

**Преимущества:**
- Надежная доставка уведомлений
- Работа при множественных экземплярах
- Автоматическое переподключение при сбоях

**Решение 3: Транзакционная обработка в БД**

**Механизм:**
- Использование SELECT FOR UPDATE при чтении заявок для опроса
- Только один экземпляр может заблокировать строку для обработки
- Автоматическая координация через БД

**Преимущества:**
- Не требует дополнительной инфраструктуры (Redis)
- Использование возможностей PostgreSQL
- Гарантированная консистентность

### 7.3. Рекомендуемое решение

**Комбинированный подход:**
1. **Распределенная блокировка (Redis)** - для координации опроса решений
2. **WebSocket через sticky sessions** - для маршрутизации соединений
3. **Транзакционная обработка в БД** - для гарантии консистентности

## 8. Архитектура обработки заявки

### 8.1. Поток обработки заявки

1. **Веб-приложение** создает заявку через REST API в **core-app**
2. **core-app** создает заявку через REST API в **osago-aggregator**
3. **osago-aggregator**:
   - Сохраняет заявку в БД
   - Параллельно отправляет заявки во все доступные страховые компании (с Circuit Breaker и Retry)
   - Возвращает `requestId` в core-app
4. **core-app** возвращает `applicationId` в веб-приложение
5. **Веб-приложение** подключается к WebSocket для получения предложений
6. **osago-aggregator** асинхронно опрашивает решения по заявкам:
   - Использует распределенную блокировку для координации между экземплярами
   - При получении предложения сохраняет его в БД
   - Отправляет уведомление через WebSocket в core-app
7. **core-app** получает уведомление и отправляет его в веб-приложение через WebSocket
8. **Веб-приложение** отображает предложение на экране пользователя
9. По истечении 60 секунд опрос завершается, даже если не все компании ответили

### 8.2. Обработка ошибок

**Сценарий 1: Сбой одной страховой компании**
- Circuit Breaker переводит компанию в состояние Open
- Опрос этой компании прекращается
- Остальные компании продолжают обрабатываться
- Частичный результат возвращается пользователю

**Сценарий 2: Таймаут при создании заявки**
- Retry механизм делает повторные попытки
- При неудаче заявка помечается как "частично создана"
- Опрос продолжается для успешно созданных заявок

**Сценарий 3: Таймаут 60 секунд**
- Все активные опросы завершаются
- Возвращаются все полученные предложения
- Пользователь видит доступные предложения

## 9. Масштабирование

### 9.1. Горизонтальное масштабирование

**osago-aggregator:**
- Масштабируется независимо от core-app
- Каждый экземпляр может обрабатывать заявки параллельно
- Координация через Redis и БД

**core-app:**
- Масштабируется для обработки запросов от веб-приложения
- WebSocket соединения распределяются через load balancer с sticky sessions

**Веб-приложение:**
- Статический контент через CDN
- API запросы через load balancer

### 9.2. Вертикальное масштабирование

- Увеличение ресурсов для osago-aggregator при росте количества страховых компаний
- Увеличение ресурсов для core-app при росте количества пользователей

## 10. Мониторинг и наблюдаемость

### 10.1. Метрики

**osago-aggregator:**
- Количество созданных заявок в секунду
- Количество полученных предложений
- Время ответа страховых компаний
- Состояние Circuit Breaker для каждой компании
- Количество таймаутов
- Количество ошибок по типам

**core-app:**
- Количество активных WebSocket соединений
- Время обработки заявок
- Количество полученных предложений

**Веб-приложение:**
- Количество активных пользователей
- Время отображения предложений

### 10.2. Логирование

- Структурированное логирование всех операций
- Трассировка запросов через requestId
- Логирование ошибок с контекстом

### 10.3. Алертинг

- Алерты при превышении порога ошибок
- Алерты при недоступности страховых компаний
- Алерты при превышении времени обработки

## 11. Выводы

Реализация продажи ОСАГО через отдельный сервис **osago-aggregator** с использованием:
- ✅ Собственного хранилища данных для состояния заявок и предложений
- ✅ REST API + WebSocket для интеграции с core-app
- ✅ WebSocket для доставки предложений в реальном времени
- ✅ Паттернов отказоустойчивости (Rate Limiting, Circuit Breaker, Retry, Timeout)
- ✅ Координации между множественными экземплярами через Redis и БД

Обеспечивает:
- Масштабируемость до 2500 одновременных пользователей
- Отображение предложений в реальном времени
- Отказоустойчивость при сбоях страховых компаний
- Соответствие требованию таймаута 60 секунд

