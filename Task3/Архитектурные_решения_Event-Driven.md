# Архитектурные решения для перехода на Event-Driven архитектуру

## Обзор изменений

Текущая синхронная архитектура с периодическими REST API запросами заменена на асинхронную Event-Driven архитектуру с использованием Message Broker (Apache Kafka). Это решает проблемы масштабируемости, отказоустойчивости и консистентности данных.

## Изменения во взаимодействиях

### 1. ins-product-aggregator → core-app и ins-comp-settlement

**Было:**
- Синхронные REST API запросы
- core-app: раз в 15 минут
- ins-comp-settlement: раз в сутки
- Локальные реплики данных

**Стало:**
- **Event-Driven через Kafka Topic `products.updated`**
- ins-product-aggregator публикует события при обновлении продуктов
- core-app подписывается на события и обновляет локальную реплику асинхронно
- ins-comp-settlement подписывается на события и получает актуальные данные в реальном времени

**Преимущества:**
- Данные обновляются сразу при изменении, а не по расписанию
- Нет пиковых нагрузок от периодических запросов
- Ошибки одной страховой компании не блокируют получение данных от других
- Масштабируемость: добавление новых страховых компаний не влияет на производительность

### 2. core-app → ins-comp-settlement

**Было:**
- Синхронный REST API запрос раз в сутки
- Получение всех оформленных за день страховок

**Стало:**
- **Event-Driven через Kafka Topic `policies.created`**
- core-app публикует событие при каждой оформленной страховке
- ins-comp-settlement подписывается на события и получает данные в реальном времени
- Использование Transactional Outbox для гарантированной доставки

**Преимущества:**
- Нет необходимости в периодическом опросе
- Данные поступают в реальном времени
- Гарантированная доставка через Transactional Outbox
- Снижение нагрузки на core-app

## Использование Transactional Outbox Pattern

### Решение: Использовать Transactional Outbox

**Обоснование:**
1. **Гарантированная доставка событий** - события не теряются даже при сбоях
2. **Консистентность данных** - событие публикуется только после успешного сохранения в БД
3. **Надежность** - события из Outbox Table обрабатываются даже после перезапуска сервиса
4. **Простота реализации** - не требует сложных механизмов двухфазного коммита

### Реализация

**Компоненты:**
1. **Outbox Table в core-db** - таблица для хранения событий в той же БД, что и бизнес-данные
2. **Outbox Processor** - отдельный сервис, который опрашивает Outbox Table и публикует события в Kafka
3. **Транзакционная запись** - core-app записывает событие в Outbox Table в той же транзакции, что и бизнес-данные

**Процесс:**
1. core-app обрабатывает бизнес-логику (оформление страховки)
2. В той же транзакции записывается событие в Outbox Table
3. Транзакция коммитится
4. Outbox Processor опрашивает Outbox Table (polling)
5. Найденные события публикуются в Kafka
6. После успешной публикации событие помечается как обработанное

**Преимущества подхода:**
- Атомарность: событие либо записывается вместе с данными, либо нет
- Надежность: события не теряются при сбоях
- Простота: не требует сложной инфраструктуры
- Производительность: асинхронная обработка не блокирует бизнес-логику

## Архитектура Message Broker

### Выбор: Apache Kafka

**Обоснование:**
1. **Масштабируемость** - горизонтальное масштабирование, поддержка больших объемов данных
2. **Надежность** - репликация данных, гарантия доставки
3. **Производительность** - высокая пропускная способность
4. **Персистентность** - события хранятся и могут быть перечитаны
5. **Поддержка множественных подписчиков** - несколько сервисов могут подписаться на один топик

### Топики Kafka

1. **`products.updated`**
   - Публикует: ins-product-aggregator
   - Подписываются: core-app, ins-comp-settlement
   - Содержимое: обновленная информация о продуктах и тарифах

2. **`policies.created`**
   - Публикует: core-app (через Outbox Processor)
   - Подписываются: ins-comp-settlement
   - Содержимое: информация об оформленной страховке

## Сохранение обратной совместимости

### REST API для ins-product-aggregator

**Решение:** Сохранить REST API для обратной совместимости и прямых запросов

**Причины:**
- Возможность прямых запросов при необходимости
- Постепенная миграция существующих интеграций
- Резервный механизм при проблемах с Kafka

**Использование:**
- REST API используется только для прямых запросов
- Основное взаимодействие через события
- Постепенный отказ от REST API после полной миграции

## Преимущества новой архитектуры

### 1. Масштабируемость

- **Горизонтальное масштабирование** - добавление новых страховых компаний не влияет на производительность
- **Параллельная обработка** - запросы к разным страховым компаниям обрабатываются параллельно
- **Масштабирование подписчиков** - каждый сервис может масштабироваться независимо

### 2. Отказоустойчивость

- **Изоляция ошибок** - ошибка одной страховой компании не влияет на другие
- **Частичный успех** - получение данных от доступных компаний даже при сбоях некоторых
- **Retry механизм** - автоматические повторные попытки при временных сбоях
- **Dead Letter Queue** - обработка проблемных событий

### 3. Актуальность данных

- **Реальное время** - данные обновляются сразу при изменении
- **Нет задержек** - нет необходимости ждать следующего периодического запроса
- **Консистентность** - все подписчики получают одинаковые данные

### 4. Производительность

- **Асинхронная обработка** - не блокирует выполнение других операций
- **Снижение нагрузки** - нет пиковых нагрузок от периодических запросов
- **Оптимизация ресурсов** - эффективное использование ресурсов серверов

### 5. Снижение связанности

- **Слабая связанность** - сервисы не знают друг о друге напрямую
- **Независимое развертывание** - сервисы могут развертываться независимо
- **Гибкость** - легко добавлять новых подписчиков без изменения существующих сервисов

## Миграционная стратегия

### Этап 1: Внедрение Kafka и базовой инфраструктуры
- Развертывание Apache Kafka
- Настройка топиков
- Создание Outbox Table и Outbox Processor

### Этап 2: Параллельная работа (Dual Write)
- ins-product-aggregator публикует события И продолжает отвечать на REST запросы
- core-app подписывается на события И продолжает делать периодические запросы
- Постепенное увеличение нагрузки на события

### Этап 3: Полный переход
- Отключение периодических запросов в core-app
- Отключение периодических запросов в ins-comp-settlement
- REST API остается для обратной совместимости

### Этап 4: Оптимизация
- Мониторинг и оптимизация производительности
- Настройка retention policy для Kafka
- Оптимизация обработки событий

## Мониторинг и наблюдаемость

### Метрики для отслеживания

1. **Kafka метрики:**
   - Lag потребителей (consumer lag)
   - Пропускная способность топиков
   - Размер топиков

2. **Метрики Outbox Processor:**
   - Количество обработанных событий
   - Время обработки событий
   - Ошибки публикации

3. **Метрики сервисов:**
   - Время обработки событий
   - Количество обработанных событий
   - Ошибки обработки

4. **Бизнес-метрики:**
   - Время обновления данных о продуктах
   - Актуальность данных
   - Количество потерянных событий (должно быть 0)

## Риски и митигация

### Риск 1: Потеря событий

**Митигация:**
- Transactional Outbox гарантирует сохранение событий
- Репликация Kafka обеспечивает надежность хранения
- Мониторинг consumer lag для обнаружения проблем

### Риск 2: Задержки обработки

**Митигация:**
- Настройка количества партиций для параллельной обработки
- Масштабирование потребителей
- Мониторинг времени обработки

### Риск 3: Проблемы с Kafka

**Митигация:**
- Кластер Kafka с репликацией
- Мониторинг состояния Kafka
- План восстановления при сбоях
- Сохранение REST API как резервного механизма

## Выводы

Переход на Event-Driven архитектуру с использованием Apache Kafka и Transactional Outbox Pattern решает все выявленные проблемы:

1. ✅ **Масштабируемость** - система готова к росту количества страховых компаний
2. ✅ **Отказоустойчивость** - ошибки изолированы, частичный успех возможен
3. ✅ **Актуальность данных** - данные обновляются в реальном времени
4. ✅ **Производительность** - асинхронная обработка, нет пиковых нагрузок
5. ✅ **Надежность** - Transactional Outbox гарантирует доставку событий

Архитектура готова к масштабированию и росту нагрузки.

